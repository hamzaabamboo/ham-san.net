---
import { formatDistance } from 'date-fns';
import { enUS, ja } from 'date-fns/locale';
import groupBy from 'lodash/groupBy';
import sortBy from 'lodash/sortBy';
import { Container, Divider, Grid, GridItem, HStack, Stack, Wrap } from 'styled-system/jsx';
import { formatMonthYear, parseDate } from 'utils/date';
import { toKebabCase } from 'utils/kebab-case';
import { Markdown } from '~/components/lib/Markdown';
import { TagBadge } from '~/components/tags/TagBadge';
import { Heading } from '~/components/ui/heading';
import { Link } from '~/components/ui/link';
import { Text } from '~/components/ui/text';
import { graphQLSdk } from '~/graphql';
import { toLegacyFetchAboutMe } from '~/graphql/legacy';
import { useTranslations, validateLocale } from '~/i18n/utils';
import MainLayout from '~/layouts/MainLayout.astro';
import { sortTags } from '~/utils/tags';

export const prerender = false;
//TODO:

const { locale } = Astro.params;

if (!validateLocale(locale)) {
  return Astro.redirect('/404');
}

const t = useTranslations(locale);

const formatDateRange = (start?: string, end?: string) => {
  const startText = start ? formatMonthYear(parseDate(start), locale) : '';
  const endText = end ? formatMonthYear(parseDate(end), locale) : t('common.present');
  if (!startText) return endText === t('common.present') ? '' : endText;
  return `${startText} - ${endText}`;
};

const formatDuration = (start?: string, end?: string) => {
  if (!start) return '';
  const startDate = parseDate(start);
  const endDate = end ? parseDate(end) : new Date();
  const startText = formatMonthYear(startDate, locale);
  const endText = end ? formatMonthYear(endDate, locale) : t('common.present');
  if (!startText || (end && !endText)) return '';
  return formatDistance(startDate, endDate, {
    locale: locale === 'ja' ? ja : enUS
  });
};

const data = toLegacyFetchAboutMe(
  await graphQLSdk.fetchAboutMe({
  // TODO: Localize Japanese Text
  locale: 'en'
})
);

//TODO: Tags
const { aboutMe, educations, experiences, tags: _tags } = data ?? {};

const skills = groupBy(
  _tags?.data?.filter(
    (tag) =>
      !!tag.attributes?.title &&
      !!tag.attributes?.slug &&
      !!tag.attributes?.type &&
      tag.attributes.type !== 'Non_Dev' &&
      tag.attributes.type !== 'NonDev'
  ),
  (tag) => tag.attributes?.type
);

Astro.response.headers.set('CDN-Cache-Control', 'public, max-age=3600, must-revalidate');
---

<MainLayout>
  <Container>
    <HStack alignItems="flex-start">
      <Stack p="4" w="full">
        <Heading as="h1" size="2xl" fontWeight="bold" id="introduction"
          >{t('about-me.title')}</Heading
        >
        <Text>{aboutMe?.data?.attributes?.introduction}</Text>
        <Divider />
        <Stack>
          <Heading as="h2" size="xl" fontWeight="bold" id="skills">{t('about-me.skills')}</Heading>
          <Grid gridTemplateColumns={{ base: '1fr', md: 'auto 1fr' }}>
            {
              skills &&
                Object.keys(skills).map((key) => {
                  return (
                    <>
                      <GridItem>
                        <Text fontWeight="bold">
                          {t(`common.${toKebabCase(key) as 'frontend'}`)}
                        </Text>
                      </GridItem>
                      <GridItem>
                        <Wrap>
                          {sortBy(skills[key], (d) => d.attributes?.projects?.data?.length ?? 0)
                            .reverse()
                            .map(
                              (s) =>
                                s.attributes?.slug && (
                                  <Link href={`/${locale}/tags/${s.attributes.slug}`}>
                                    <TagBadge tag={s.attributes} showCount />
                                  </Link>
                                )
                            )}
                        </Wrap>
                      </GridItem>
                    </>
                  );
                })
            }
          </Grid>
        </Stack>
        <Divider />
        <Stack>
          <Heading as="h2" size="xl" fontWeight="bold" id="experiences"
            >{t('common.experiences')}</Heading
          >
          {
            experiences &&
              experiences.data?.map((d) => {
                if (!d.attributes) return null;
                const { title, content, position, tags } = d.attributes;
                const start = d.attributes.start as string;
                const end = d.attributes.end as string;
                return (
                  <Stack>
                    <Heading as="h2" size="xl" fontWeight="bold">
                      {title}
                    </Heading>
                    <Wrap fontSize="sm">
                      <Text>{position}</Text> <Text>|</Text>
                      <Text>
                        {formatDateRange(start, end)}
                        {formatDuration(start, end) && ` (${formatDuration(start, end)})`}
                      </Text>
                    </Wrap>
                    {tags && (
                      <Wrap fontSize="sm" gap="2" rowGap="2" alignItems="center">
                        <Text>{t('common.tags')}</Text>
                        {sortTags(tags?.data).map(
                          (s) =>
                            s.attributes && (
                              <Link href={`/${locale}/tags/${s.attributes.slug}`} display="inline-flex">
                                <TagBadge tag={s.attributes} showCount size="sm" />
                              </Link>
                            )
                        )}
                      </Wrap>
                    )}
                    {content && <Markdown content={content} />}
                  </Stack>
                );
              })
          }
        </Stack>
        <Divider />
        <Stack>
          <Heading as="h2" size="xl" fontWeight="bold" id="education"
            >{t('common.education')}</Heading
          >
          {
            educations &&
              educations.data?.map((d) => {
                if (!d.attributes) return null;
                const { title, description, content } = d.attributes;
                const start = d.attributes.start as string;
                const end = d.attributes.end as string;
                return (
                  <Stack>
                    <Heading as="h2" size="xl" fontWeight="bold">
                      {title}
                    </Heading>
                    <Wrap fontSize="sm">
                      <Text>{description}</Text> <Text>|</Text>
                      <Text>
                        {formatDateRange(start, end)}
                      </Text>
                    </Wrap>
                    {content && <Markdown content={content} />}
                  </Stack>
                );
              })
          }
        </Stack>
      </Stack>
      <!-- <Box py="4">
        <Box position="sticky">
          <AboutMeIndex client:load locale={locale} />
        </Box>
      </Box> -->
    </HStack>
  </Container>
</MainLayout>
